\input{header.tex}

\begin{document}

\section*{Лекция 15 от 03.03.2016}

\subsection{Алгоритм Флойда-Уоршелла}

Вход: $G = (V, E)$ с весами $W_{ij}$; $V = \{1,\ldots, n\}$; в $G$ нет циклов с отрицательными весами.
Выход: $B_{ij}$ --- длина кратчайшего пути из $i$ в $j$.

Пусть OPT$(i, j, k)$ --- длина кратчайшего пути из $i$ в $j$ с промежуточными вершинами в $V_k = \{1,\ldots,k\}$.
Мы хотим найти OPT$(i, j, n)$. Воспользуемся методом динамического программирования и будем сводить нашу задачу к меньшим.

\[
    \mathrm{OPT}(i, j, 0) =
    \begin{cases}
        0, i=j;\\
        w_{ij}, i\neq j,\ (i,j) \in E;\\
        +\infty, i\neq j,\ (i,j) \not\in E;\\
    \end{cases}
\]

А если $k$ не равно нулю?

Рассмотрим кратчайший путь из $i$ в $j$ через вершины в $V_k$.
\begin{enumerate}
    \item $k \not \in i \longrightarrow j$; тогда OPT$(i, j, k) = \mathrm{OPT}(i, j, k-1)$
    \item $k \in i \longrightarrow j$; тогда $i \xrightarrow{\ \ k\ \ } j =  i \longrightarrow k \longrightarrow j$
\end{enumerate}

Несколько важных замечаний:
\begin{itemize}
    \item Если в $G$ нет циклов с отрицательным весом (если есть, то понятие ``кратчайший путь'' вообще неприменимо к той компоненте связности, в которую входит этот цикл), то хотя бы один из кратчайший путей является простым. Это несложно доказать, заметив, что если в путь в таком графе входит цикл, его можно отбросить и не увеличить длины пути.
    \item Любой сегмент кратчайшего пути является кратчайшим путём. Это утверждение очевидным образом следует из предыдущего --- если в каком-то сегменте есть цикл, то при его удалении длина пути не увеличится. 
\end{itemize}

Вернёмся ко второму случаю, который мы пока не рассмотрели полностью. Заметим, что ни на отрезке $i \longrightarrow k$, ни на отрезке $k \longrightarrow j$ не может быть промежуточной вершины $k$. Тогда OPT$(i, j, k) = \mathrm{OPT}(i, k, k-1) + \mathrm{OPT}(k, j, k-1)$.

Однако мы не знаем, входит ли $k$ в кратчайший путь. Что делать? Самый простой вариант --- вычислить кратчайший путь из тех, что проходят через $k$, кратчайший путь из тех, что не проходят, и взять тот из двух, что короче.

Итак, итоговая формула выглядит так:

\[
    \mathrm{OPT}(i, j, k) = \min
    \begin{cases}
        \mathrm{OPT}(i, j, k-1); \\
        \mathrm{OPT}(i, k, k-1) + \mathrm{OPT}(k, j, k-1)
    \end{cases}
\]

Запишем алгоритм:

\begin{lstlisting}
for i:= 1 to n
    for j:= 1 to n
        // *
        if i = j then
            B[i, j, 0] := 0
        else if (i, j) in E then
            B[i, j, 0] := w_{ij}
        else
            B[i, j, 0] := Infinity

for k:= 1 to n
    for i:= 1 to n
        for j:= 1 to n
            if B[i, j, k-1] < B[i, k, k-1] + B[k, j, k-1] then
                B[i, j, k] := B[i, j, k-1]
            else
                B[i, j, k] := B[i, k, k-1] + B[k, j, k-1]
\end{lstlisting}

Сложность алгоритма, очевидно, $O(N^3)$ --- три вложенных цикла до $N$. При этом сложность алгоритма не зависит от способа представления графа.

Очевидная оптимизация --- хранить не все значения, а только те, что соответствуют текущим $k$ и $k-1$.

Однако нам хватит даже одной матрицы размера $i\times j$:

\begin{lstlisting}
if B[i,j] > B[i, k] + B[k, j] then
    B[i,j]:= B[i, k] + B[k, j]
\end{lstlisting}

Заметим, что так делать действительно можно. Кажется, что есть опасность случайно воспользоваться уже пересчитанным значением и, вообще говоря, пользоваться значениями для различных $k$. Однако при пересчёте ничего страшного не происходит --- (тут, вообще говоря, нужно расписать то, что он говорил).

Мы предполагали, что отрицательных циклов нет. А если мы всё же запустим такой алгоритм на ``неподходящем'' графе? А ничего страшного, но для всех вершин $i$ в этом отрицательном цикле после завершения алгоритма будет выполняться $B_{ii} < 0$. Разумеется, в таком случае остальным значениям в $B$ верить вообще нельзя --- в таком графе не определено само понятие ``кратчайший путь''.

А давайте введём ещё матрицу $C$ и будем заполнять её так, чтобы можно было восстановить ответ:

\begin{lstlisting}
if B[i,j] > B[i, k] + B[k, j] then
    B[i,j]:= B[i, k] + B[k, j]
    C[i, j]:= k
\end{lstlisting}

А как восстановить решение?

\begin{lstlisting}
Reconstruct(C, i, j)
    if C[i, j] = NULL then return *
    k = C[i, j]
    return Reconstruct(C, i, k) + [k] + Reconstruct(C, k, j)
\end{lstlisting}

\subsection{Алгоритм Беллмана-Форда}
Вход: $G = (V, E)$ с весами $W_{ij}$; $V = \{1,\ldots, n\}$; в $G$ нет циклов с отрицательными весами; $s \in V$.
Выход: $B_{ij}$ --- длина кратчайшего пути из $i$ в $j$.

OPT$(k, j)$ --- длина кратчайшего пути из $s$ в $j$, содержащих не более $k$ рёбер.

Базовый случай: 

\[
    \mathrm{OPT}(0, j) = \begin{cases}
        0, j = s;
        +\infty, j\neq s
    \end{cases}
\]

В общем случае, на $k$-ом шаге мы либо пользуемся путём с прошлого шага, либо путём длины ровно $k$. Как их рассмотреть?

\[
    \mathrm{OPT}(k, j) = \min \begin{cases}
        \mathrm{OPT}(k-1, j),\\
        \min\{\mathrm{OPT}(k-1,l)+w_{lj}\mid (l, j)\in E\}
    \end{cases}
\]

Заметим, что так как кратчайший путь --- простой, ответом на задачу будет являться OPT$(n-1, j)$.

Алгоритм:

\begin{lstlisting}
for j:=1 to n do
    if j = s then
        B[0, j] = 0
    else
        B[0, j] = Infinity
for k:= 1 to n-1 do
    B[k, j] = B[k-1, j]
    for (l, j) in E do 
        if B[k, j] > B[k-1, l] + w_{lj} then
            B[k, j] := B[k-1, l] + w_{lj}
\end{lstlisting}

\end{document}
