\input{header.tex}

\begin{document}

\section*{Лекция ?? от 15.03.2016}

\subsection{Ассоциативный массив}

Продолжаем говорить про структуры данных. Ассоциативный массив (он же map в C++, он же словарь в Python). Это структура данных такая, что с каждой записью ассоциирован уникальный ключ и реализованы следующие операции:

Insert(S, x)

Delete(S, x)

Find(S, k)

Возможные способы:

Таблица с прямой адресацией:

Ключи берутся из $U = \{0,\ldots, m-1\}$; данные будем хранить в массиве размера m; все операции быстры, ожнако если мы хотим, чтобы ключи были, например, long'ами, то у нас такая таблица в память не поместится вообще никак. А что делать, если $U$ большое, бесконечное, например?

Хеш-функция:

Пусть есть функция $h: U\to \{0, \ldots, m-1\}$. При этом, записывать элемент будем в ячейку $h(k)$. Возможно, что двум ключам соответствует один хеш; тогда возникает \emph{коллизия}, и их можно решать разными способами. Например, можно хранить не элементы, а списки элементов с соответствующим хешем; необходимо только модифицировать наши функции.

\begin{lstlisting}
Find(T, k)
    list := T[h(k)]
    return k in list
\end{lstlisting}

Проблема этого подхода --- случай, когда хеши всех ключей равны. Тогда таблица вырождается в список, а он очень неэффективен. Худший случай для Find --- $O(n)$, в отличие от $O(1)$ в лучшем. А давайте рассмотрим средний случай?

Будем считать, что $h$ хорошая и распределяет $n$ ключей по $m$ хешам примерно равномерно. Пусть $\alpha = \frac{n}{m}$ --- коэффициент заполнения.

Ожидаемое время поиска отсутствующего элемента --- $O(1+\alpha)$. При этом, если $n = O(m)$, то поиск занимает $O()$

Но нам нужна хорошая функция. Где её взять?

Метод деления:

$h(x) = x \pmod{m}$.

Однако, если у нас, например, $m$ чётное, а так сложилось, что мы работаем с чётными числами, то половина ячеек нашей хеш-таблицы будет пустой. (Вообще, обычно $m$ берут простым и всё хорошо)

Метод умножения:

$h(k) = (ak\pmod{2^w}) >> (w-r)$, где $w$ --- длина слова.


А теперь снова к коллизиям. Можно использовать не списки, а таблицу с открытой адресацией, где используются по очереди несколько ($m$) хеш-функций, пока очередной хеш от ключа не окажется незанят. При этом мы хотим хоть какой-то эффективности, поэтому иметь больше чем $m$ функций --- излишне; значит, мы хотим, чтобы для всех $k,\ i\neq j$ выполнялось $h(k, i) \neq h(k, j)$.

Самый простой способ --- имея одну функцию $h'(k)$ определить $h(k, i) = (h'(k) + i) \pmod{m}$. Этот вариант не очень хорош --- будут образовываться большие подряд занятые блоки и они будут замедлять работу.

Лучше сделать так: $h(k, i) = (h'(k) + ih''(k)) \pmod{m}$.

А теперь поговорим об эффективности поиска:

Для каждого ключа все $m!$ перестановок равновероятны.

$\alpha = \frac{n}{m} < 1$

\[
    1+\frac{n}{m}\left(1+\frac{n-1}{m-1}\left(1+\frac{n-2}{m-2}\cdots\right)\right) \leqslant 1+\alpha(1+\alpha(1+\alpha\cdots)) \leqslant \frac{1}{1-\alpha}
\]<++>
\end{document}
