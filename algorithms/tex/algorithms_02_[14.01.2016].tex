\input{header.tex}

\begin{document}
	
\section{Лекция 2 от 14.01.2016}

\subsection{Задача сортировки. Сортировка вставками}
На сегодняшней лекции мы будем рассматривать классическую задачу мира алгоритмов, встречающуюся на практике повсеместно~--- \emph{задачу сортировки}. Поставим её формально.

\textbf{Вход:} последовательность из \(n\) чисел \([a_{1}, a_{2}, \ldots, a_{n}]\).

\textbf{Выход:} последовательность из \(n\) чисел \([a'_{1}, a'_{2}, \ldots, a'_{n}]\) такая, что \(a'_{1} \leqslant a'_{2} \leqslant \ldots \leqslant a'_{n}\).

Как её решить? Один из самых простых алгоритмов сортировки устроен рекурсивно. Пусть на вход подаётся массив из \(n\) элементов и последний элемент в нём равен \(k\). Тогда вызываем этот же алгоритм от первых \(n - 1\) элемента, после чего делаем следующее: до тех пор, пока элемент, стоящий перед \(k\), больше \(k\), меняем их местами. В псевдокоде это будет записано так:

\begin{algorithm}[H]
	\caption{Неэффективный алгоритм сортировки}
\begin{algorithmic}[1]
	\Function{Recursive-Sort}{$A$}
	\If{\(A.length > 1\)}
		\State \textsc{Recursive-Sort}($A[1:A.length - 1]$)
		\State \(key \mathrel{:=} A[j]\)
		\State \(i \mathrel{:=} j - 1\)
		\While{\(i > 0\) \textbf{and} \(A[i] > key\)}
			\State \(A[i + 1] \mathrel{:=} A[i]\)
			\State \(i \mathrel{:=} i - 1\)
		\EndWhile
		\State \(A[i + 1] \mathrel{:=} key\)
	\EndIf
	\EndFunction
\end{algorithmic}
\end{algorithm}
Покажем, как работает этот алгоритм, на примере массива \([6, 8, 3, 4]\):

\begin{itemize}
	\item Сначала вызовем этот алгоритм от массива \([6, 8, 3]\). Легко проверить, что в итоге получится массив \([3, 6, 8]\).
	\item Далее сравниваем 4 с стоящим впереди элементом и меняем их местами, если необходимо:
	\[[3, 6, 8, 4] \mapsto [3, 6, 4, 8] \mapsto [3, 4, 6, 8]\]
\end{itemize}
В итоге получилась отсортированная последовательность. По сути, алгоритм вставляет элементы на нужные места в уже отсортированный массив.

Теперь рассмотрим алгоритм \emph{сортировки вставками}:

\begin{algorithm}[H]
	\caption{Алгоритм сортировки вставками}
	\begin{algorithmic}[1]
		\Function{Insertion-Sort}{$A$}
		\For{\(j \mathrel{:=} 2\) \textbf{to} \(A.length\)}\Comment{вставка \(A[j]\) в отсортированный массив \(A[1..j - 1]\)}
			\State \(key \mathrel{:=} A[j]\)
			\State \(i \mathrel{:=} j - 1\)
			\While{\(i > 0\) \textbf{and} \(A[i] > key\)}
				\State \(A[i + 1] \mathrel{:=} A[i]\)
				\State \(i \mathrel{:=} i - 1\)
			\EndWhile
			\State \(A[i + 1] \mathrel{:=} key\)
		\EndFor
		\EndFunction
	\end{algorithmic}
\end{algorithm}

Нетрудно заметить, что он делает то же самое, что и описанный ранее алгоритм, только без рекурсивных вызовов.

Возникает логичный вопрос~--- а можем ли мы сказать, что этот алгоритм делает именно то, что нам нужно? Другими словами, \emph{корректен} ли он? Оказывается, что да. Докажем это.

Для этого стоит рассмотреть так называемый \emph{инвариант цикла}~--- нечто, что не изменяется при переходе на следующую итерацию цикла. В данном случае он будет таков: на \(j\)-й итерации цикла первые \(i - 1\) элементов массива будут упорядочены.

Далее нужно рассмотреть три свойства инварианта цикла:
\begin{itemize}
	\item \textbf{Инициализация:} Инвариант цикла выполняется на первой итерации;
	
	\item \textbf{Переход:} Инвариант сохраняется при переходе на следующую итерацию;
	
	\item \textbf{Завершение:} При окончании цикла инвариант даёт какое-то ценное свойство полученного массива.
\end{itemize}
Можно сказать, что первые два свойства доказывают корректность инварианта. Приступим:
\begin{itemize}
	\item \textbf{Инициализация:} На первой итерации цикла элемент вставляется в массив из одного элемента. Но он, очевидно, отсортирован. Тогда инвариант цикла выполняется для первой итерации.
	
	\item \textbf{Переход:} Пусть массив \([a_1, \ldots, a_{j - 1}]\) уже отсортирован. В теле цикла делается следующее: до тех пор, пока \(a_{j}\) меньше стоящего перед ним элемента, они меняются местами. По сути, элемент просто вставляется на нужное место. Тогда инвариант выполняется при переходе на следующую итерацию. Следовательно, инвариант корректен.
	
	\item \textbf{Завершение:} Цикл завершается тогда, когда \(j = n + 1\). Заметим, что это будет итерация под номером \(n\). Но тогда (согласно инварианту цикла) первые \(n\) элементов массива, то есть весь массив, будут упорядочены. Тогда в конце массив окажется отсортированным. Тем самым мы доказали, что алгоритм корректен.
\end{itemize}

Хорошо, он корректен. Но насколько быстро он работает? Достаточно очевидны три факта:
\begin{itemize}
	\item Скорость работы зависит от входных данных;
	\item Чем больше элементов, тем дольше будет работать алгоритм;
	\item Если алгоритм уже отсортирован, то он будет работать быстрее.
\end{itemize}
Обычно время работы рассматривают в трёх случаях~--- в худшем, в лучшем и в среднем. Хотя оценка в лучшем случае не несёт особо ценной информации, так как всегда можно модифицировать алгоритм так, что на некоторых наборах данных он будет работать очень быстро.

Для оценки времени работы введём асимптотическую оценку \(\Theta\):
\[\Theta(g(n)) = \{f(n)\mid\exists\,c_1, c_2 > 0: \forall n\geqslant n_0 \implies 0 \leqslant c_1g(n) \leqslant f(n) \leqslant c_2g(n)\}\]

Рассмотрим следующий пример. Пусть \(f(n) = 3n^2 + 2n + 6\). Тогда \(f(n) \in \Theta(n^2)\). Хотя правильней писать так, но на практике все пишут, что \(f(n) = \Theta(n^2)\).

Стоит обратить внимание, что асимтотическая оценка показывает рост функции. Но не стоит забывать про константы~--- может выйти так, что для достаточно маленьких \(n\) функция из \(\Theta(n^3)\) работает быстрее, чем функция из \(\Theta(n)\):
\begin{center}
	\begin{tikzpicture}
	\begin{axis}
	\addplot [domain=0:5, samples=101,unbounded coords=jump]{x+30} node[below,pos=0.9] {$x + 30$};
	\addplot [domain=0:5, samples=101,unbounded coords=jump]{0.2 * x^3} node[below,pos=0.85] {$\quad \frac{x^3}{5}$};
	\end{axis}
	\end{tikzpicture}
\end{center}

Вернёмся к оценке времени работы алгоритма. Пусть его скорость работы равна \(T(n)\).

Рассмотрим худший случай. Когда он достигается? Когда приходится делать максимальное число перестановок. Тогда на \(i\)-й итерации совершается \(\Theta(i)\) операций. Следовательно, \[T(n) = \sum_{k = 0}^{n} \Theta(k) = \Theta(n^2).\]

В среднем случае все исходы равновероятны. Тогда в среднем будет выполняться половина всех возможных перестановок. А это \(\Theta(n^2)\).

В лучшем случае не совершается ни одной перестановки. Это означает, что массив уже отсортирован. Тогда алгоритм работает за \(\Theta(n)\) (так как он просто проходится по массиву).

\subsection{Сортировка слиянием}

% TODO: добавить доказательство корректности Merge-Sort и нормальное оценивание времени работы.

Рассмотрим другой алгоритм --- \emph{сортировку слиянием}.

\begin{algorithm}[H]
	\caption{Алгоритм сортировки слиянием}
	\begin{algorithmic}[1]
		\Function{Merge-Sort}{$A$}
		\State \(n \mathrel{:=} A.length\)
		\If{\(n > 1\)}
			\State \(B_1 \mathrel{:=} \textsc{Merge-Sort}\left(A\left[1:\left\lfloor\frac{n}{2}\right\rfloor\right]\right)\)
			\State \(B_2 \mathrel{:=} \textsc{Merge-Sort}\left(A\left[\left\lfloor\frac{n}{2}\right\rfloor + 1 : n\right]\right)\)
			\State \(A \mathrel{:=} \textsc{Merge}(B_1, B_2)\) \Comment{сливаем два отсортированных массива в один}
		\EndIf
		\State return \(A\)
		\EndFunction
	\end{algorithmic}
\end{algorithm}

Рассмотрим, как может работать \textsc{Merge}\((B_1, B_2)\) на примере. Пусть даны массивы \(B_1 \mathrel{:=} [2,5,6,8]\) и \(B_2 \mathrel{:=} [1,3,7,9]\).

Будем сливать элементы из массивов в результирующий массив $b$, сравнивая поочерёдно минимальные элементы, которые ещё не вошли в результирующий массив. 

\begin{itemize}
	\item $2 > 1$. Тогда $b[1] \mathrel{:=} b_2[1] = 1$ (будем считать, что нумерация идёт с единицы).
	\item $2 < 3$. Тогда $b[2] \mathrel{:=} b_1[1] = 2$.
	\item Аналогично продолжаем для всех остальных элементов массивов.
\end{itemize}
Очевидно, что алгоритм корректен, а его сложность --- линейная, так как мы один раз проходим по массивам, то есть $\Theta(n)$.

Пусть худшее время для \textsc{Merge-Sort}~--- $T(n)$. Тогда

\[T(n) = \begin{cases}
\Theta(1), & n = 1\\
2T(n/2)+\Theta(n), & n > 1
\end{cases}\]

Построим дерево рекурсии:

\begin{center}
	\begin{forest}
		for tree={
			%parent anchor=south,
			%child anchor=north,
			if n children=0{
				font=\itshape,
				%tier=terminal,
			}{},
		}
		[$T(n)$ [$T(n/2)$ [$T(n/4)$ [\ldots] [\ldots] [\ldots]]
		[$cn/2$]
		[$T(n/4)$ [\ldots] [\ldots] [\ldots]]]
		[$cn$]
		[$T(n/2)$ [$T(n/4)$ [\ldots] [\ldots] [\ldots]]
		[$cn/2$]
		[$T(n/4)$ [\ldots] [\ldots] [\ldots]]]]
	\end{forest}
\end{center}

На каждом уровне $\Theta(n)$ работы, а высота дерева~--- $\log_{2} n$. Общее время работы~--- $\Theta(n)\log n = \Theta(n\log{n})$.
\end{document}
